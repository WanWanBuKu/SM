<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å›½é™…è·³æ£‹- å¯¹æˆ˜å‡‰å®‰</title>
</head>

        <!-- å¼•å…¥æ•°æ®åº“ç®¡ç†å™¨ -->
    <script src="/db.js"></script>
    
        <!-- å¼•å…¥æ’ä»¶å·¥å…·ç®± ğŸ„-->
    <script src="/A2_å…¨å±€ä¸­å¿ƒ/B_æ’ä»¶å·¥å…·/toolbox.js"></script>      
    
<body>
    <div class="header">
        <h1>â™Ÿï¸å›½é™…è·³æ£‹</h1>
        <div class="stats">
            <div class="stat-item">ğŸ†èƒœåˆ©: <span id="wins">0</span></div>
            <div class="stat-item">ğŸ’”å¤±è´¥: <span id="losses">0</span></div>
            <div class="stat-item">ğŸ¤å¹³å±€: <span id="draws">0</span></div>
        </div>
    </div>
    <div class="game-container">
        <div class="board" id="board"></div>
        <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">æ–°æ¸¸æˆ</button>
            <button class="btn btn-secondary" onclick="resetStats()">é‡ç½®ç»Ÿè®¡</button>
        </div>
        <div class="status" id="status">ä½ çš„å›åˆ- è“è‰²æ£‹å­</div>
    </div>

    <script src="13_styles.js"></script>
    <script>
        class CheckersGame {
            constructor() {
                this.board = [];
                this.currentPlayer = 'player';
                this.selectedPiece = null;
                this.validMoves = [];
                this.mustCapture = false;
                this.captureChain = false;
                this.gameOver = false;
                this.stats = this.loadStats();
                this.initBoard();
                this.renderBoard();
                this.updateStats();
                this.loadGameState();
            }

            initBoard() {
                // åˆå§‹åŒ–8x8 æ£‹ç›˜
                this.board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // æ”¾ç½®ç©å®¶æ£‹å­ï¼ˆè“è‰²ï¼Œåº•éƒ¨ï¼‰
                for (let row = 5; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { type: 'player', king: false };
                        }
                    }
                }
                
                // æ”¾ç½®å‡‰å®‰æ£‹å­ï¼ˆæ©™è‰²ï¼Œé¡¶éƒ¨ï¼‰
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 8; col++) {
                        if ((row + col) % 2 === 1) {
                            this.board[row][col] = { type: 'ai', king: false };
                        }
                    }
                }
            }

            renderBoard() {
                const boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        if (this.selectedPiece && this.selectedPiece.row === row && this.selectedPiece.col === col) {
                            square.classList.add('selected');
                        }
                        
                        if (this.validMoves.some(move => move.row === row && move.col === col)) {
                            square.classList.add('valid-move');
                        }
                        
                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceElement = document.createElement('div');
                            pieceElement.className = `piece ${piece.type}`;
                            if (piece.king) {
                                pieceElement.classList.add('king');
                            }
                            square.appendChild(pieceElement);
                        }
                        
                        square.addEventListener('click', () => this.handleSquareClick(row, col));
                        boardElement.appendChild(square);
                    }
                }
            }

            handleSquareClick(row, col) {
                if (this.gameOver || this.currentPlayer !== 'player') return;
                
                const piece = this.board[row][col];
                
                if (this.selectedPiece) {
                    // å°è¯•ç§»åŠ¨åˆ°ç‚¹å‡»çš„ä½ç½®
                    const move = this.validMoves.find(m => m.row === row && m.col === col);
                    if (move) {
                        this.makeMove(this.selectedPiece, move);
                    } else if (piece && piece.type === 'player') {
                        // é€‰æ‹©æ–°çš„æ£‹å­
                        this.selectPiece(row, col);
                    } else {
                        // å–æ¶ˆé€‰æ‹©
                        this.selectedPiece = null;
                        this.validMoves = [];
                        this.renderBoard();
                    }
                } else if (piece && piece.type === 'player') {
                    // é€‰æ‹©æ£‹å­
                    this.selectPiece(row, col);
                }
            }

            selectPiece(row, col) {
                this.selectedPiece = { row, col };
                this.validMoves = this.getValidMoves(row, col);
                
                // æ£€æŸ¥æ˜¯å¦å¿…é¡»åƒå­
                const allCaptures = this.getAllCaptureMoves('player');
                if (allCaptures.length > 0) {
                    this.validMoves = this.validMoves.filter(move => move.capture);
                }
                
                this.renderBoard();
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const moves = [];
                
                if (piece.king) {
                    // ç‹æ£‹å¯ä»¥æ²¿ç€å››ä¸ªå¯¹è§’çº¿æ–¹å‘ç§»åŠ¨ä»»æ„è·ç¦»
                    const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
                    
                    for (const [dr, dc] of directions) {
                        // æ£€æŸ¥æ™®é€šç§»åŠ¨ï¼ˆæ²¿ç€å¯¹è§’çº¿ç§»åŠ¨ä»»æ„è·ç¦»ï¼‰
                        for (let dist = 1; dist < 8; dist++) {
                            const newRow = row + dr * dist;
                            const newCol = col + dc * dist;
                            
                            if (!this.isValidPosition(newRow, newCol)) break;
                            
                            if (this.board[newRow][newCol]) {
                                // é‡åˆ°æ£‹å­ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥åƒå­
                                if (this.board[newRow][newCol].type !== piece.type) {
                                    // æ£€æŸ¥è·³è¿‡åçš„ä½ç½®
                                    for (let jumpDist = dist + 1; jumpDist < 8; jumpDist++) {
                                        const jumpRow = row + dr * jumpDist;
                                        const jumpCol = col + dc * jumpDist;
                                        
                                        if (!this.isValidPosition(jumpRow, jumpCol)) break;
                                        
                                        if (!this.board[jumpRow][jumpCol]) {
                                            // å¯ä»¥è·³åˆ°è¿™é‡Œ
                                            moves.push({ 
                                                row: jumpRow, 
                                                col: jumpCol, 
                                                capture: true, 
                                                capturedRow: newRow, 
                                                capturedCol: newCol 
                                            });
                                            break; // ç‹æ£‹åªèƒ½è·³è¿‡ä¸€ä¸ªæ£‹å­
                                        } else {
                                            break; // è·³è¿‡è·¯å¾„ä¸Šæœ‰å…¶ä»–æ£‹å­é˜»æŒ¡
                                        }
                                    }
                                }
                                break; // é‡åˆ°æ£‹å­ååœæ­¢ç»§ç»­æ£€æŸ¥è¯¥æ–¹å‘
                            } else {
                                // ç©ºä½ï¼Œå¯ä»¥ç§»åŠ¨åˆ°è¿™é‡Œ
                                moves.push({ row: newRow, col: newCol, capture: false });
                            }
                        }
                    }
                } else {
                    // æ™®é€šæ£‹å­çš„ç§»åŠ¨é€»è¾‘
                    const directions = piece.type === 'player' ? 
                        [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]];
                    
                    for (const [dr, dc] of directions) {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        
                        if (this.isValidPosition(newRow, newCol)) {
                            if (!this.board[newRow][newCol]) {
                                moves.push({ row: newRow, col: newCol, capture: false });
                            } else if (this.board[newRow][newCol].type !== piece.type) {
                                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è·³è¿‡
                                const jumpRow = newRow + dr;
                                const jumpCol = newCol + dc;
                                
                                if (this.isValidPosition(jumpRow, jumpCol) && !this.board[jumpRow][jumpCol]) {
                                    moves.push({ 
                                        row: jumpRow, 
                                        col: jumpCol, 
                                        capture: true, 
                                        capturedRow: newRow, 
                                        capturedCol: newCol 
                                    });
                                }
                            }
                        }
                    }
                }
                
                return moves;
            }

            getAllCaptureMoves(playerType) {
                const captures = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === playerType) {
                            const moves = this.getValidMoves(row, col);
                            const captureMoves = moves.filter(move => move.capture);
                            
                            if (captureMoves.length > 0) {
                                captures.push({ row, col, moves: captureMoves });
                            }
                        }
                    }
                }
                
                return captures;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            makeMove(from, to) {
                const piece = this.board[from.row][from.col];
                this.board[to.row][to.col] = piece;
                this.board[from.row][from.col] = null;
                
                // å¤„ç†åƒå­
                if (to.capture) {
                    this.board[to.capturedRow][to.capturedCol] = null;
                }
                
                // æ£€æŸ¥è¿ç»­åƒå­
                if (to.capture) {
                    const moreCaptures = this.getValidMoves(to.row, to.col).filter(move => move.capture);
                    if (moreCaptures.length > 0) {
                        this.selectedPiece = { row: to.row, col: to.col };
                        this.validMoves = moreCaptures;
                        this.captureChain = true;
                        this.renderBoard();
                        
                        // å¦‚æœæ˜¯å‡‰å®‰çš„è¿ç»­åƒå­ï¼Œç›´æ¥ç»§ç»­åƒï¼Œä¸æ€è€ƒ
                        if (this.currentPlayer === 'ai') {
                            setTimeout(() => {
                                // å‡‰å®‰é€‰æ‹©æœ€ä¼˜çš„è¿ç»­åƒå­è·¯å¾„
                                const bestMove = this.selectBestCaptureMove(moreCaptures);
                                this.makeMove(this.selectedPiece, bestMove);
                            }, 200);
                        }
                        return;
                    }
                }
                
                // åªæœ‰åˆ°è¾¾å¯¹æ–¹åº•çº¿æ‰èƒ½å‡çº§ä¸ºç‹æ£‹
                // ç©å®¶æ£‹å­ï¼ˆè“è‰²ï¼‰åˆ°è¾¾é¡¶éƒ¨ï¼ˆç¬¬0è¡Œï¼‰å‡çº§
                // å‡‰å®‰æ£‹å­ï¼ˆæ©™è‰²ï¼‰åˆ°è¾¾åº•éƒ¨ï¼ˆç¬¬7è¡Œï¼‰å‡çº§
                if ((piece.type === 'player' && to.row === 0) || 
                    (piece.type === 'ai' && to.row === 7)) {
                    piece.king = true;
                }
                
                this.selectedPiece = null;
                this.validMoves = [];
                this.captureChain = false;
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸ
                if (this.checkGameOver()) {
                    return;
                }
                
                // åˆ‡æ¢ç©å®¶
                this.currentPlayer = this.currentPlayer === 'player' ? 'ai' : 'player';
                this.updateStatus();
                this.saveGameState();
                
                // å‡‰å®‰ç§»åŠ¨
                if (this.currentPlayer === 'ai') {
                    setTimeout(() => this.aiMove(), 500);
                }
                
                this.renderBoard();
            }

            // å‡‰å®‰é€‰æ‹©æœ€ä¼˜çš„è¿ç»­åƒå­è·¯å¾„
            selectBestCaptureMove(captureMoves) {
                // ç®€å•ç­–ç•¥ï¼šä¼˜å…ˆé€‰æ‹©èƒ½ç»§ç»­åƒå­çš„ç§»åŠ¨
                // å¯¹äºç‹æ£‹ï¼Œä¼˜å…ˆé€‰æ‹©èƒ½åƒæ›´å¤šå­çš„è·¯å¾„
                let bestMove = captureMoves[0];
                let maxCaptures = 0;
                
                for (const move of captureMoves) {
                    // æ¨¡æ‹Ÿè¿™æ¬¡ç§»åŠ¨
                    const backup = this.quickMove({ from: {r: this.selectedPiece.row, c: this.selectedPiece.col}, to: move });
                    
                    // æ£€æŸ¥è¿™æ¬¡ç§»åŠ¨åè¿˜èƒ½åƒå¤šå°‘å­
                    const furtherCaptures = this.getValidMoves(move.row, move.col).filter(m => m.capture);
                    const totalCaptures = furtherCaptures.length;
                    
                    this.quickUndo(backup);
                    
                    if (totalCaptures > maxCaptures) {
                        maxCaptures = totalCaptures;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }

            aiMove() {
                if (this.gameOver) return;
                
                // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å¼ºåˆ¶åƒå­
                const allCaptures = this.getAllCaptureMoves('ai');
                if (allCaptures.length > 0) {
                    // æœ‰åƒå­å¿…é¡»åƒï¼Œç›´æ¥æ‰§è¡Œï¼Œä¸æ€è€ƒ
                    const captureMove = allCaptures[0];
                    const move = captureMove.moves[0]; // é€‰æ‹©ç¬¬ä¸€ä¸ªå¯åƒå­çš„ç§»åŠ¨
                    
                    document.getElementById('status').innerHTML = '<span class="thinking">å‡‰å®‰è¿ç»­åƒå­ä¸­...</span>';
                    this.selectedPiece = { row: captureMove.row, col: captureMove.col };
                    this.validMoves = [move];
                    this.renderBoard();
                    
                    setTimeout(() => {
                        this.makeMove(this.selectedPiece, move);
                    }, 300);
                    
                    return;
                }
                
                // æ²¡æœ‰åƒå­æ‰éœ€è¦æ€è€ƒ
                document.getElementById('status').innerHTML = '<span class="thinking">å‡‰å®‰æ€è€ƒä¸­...</span>';
                
                setTimeout(() => {
                    const move = this.getBestMove();
                    if (move) {
                        this.selectedPiece = { row: move.from.row, col: move.from.col };
                        this.validMoves = [move.to];
                        this.renderBoard();
                        
                        setTimeout(() => {
                            this.makeMove(move.from, move.to);
                        }, 300);
                    }
                }, 800);
            }

            // åŠ å¼ºç‰ˆå‡‰å®‰- ä½¿ç”¨æå°åŒ–æœç´¢ç®—æ³•
            getBestMove() {
                const MAX_DEPTH = 3;
                const NEG_INF = -1e6, POS_INF = 1e6;
                
                // é™æ€è¯„ä»·å‡½æ•°
                const evaluate = () => {
                    let score = 0;
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const p = this.board[r][c];
                            if (!p) continue;
                            
                            let v = p.king ? 5 : 3; // ç‹5åˆ†ï¼Œå…µ3åˆ†
                            if (p.type === 'ai') score += v;
                            else score -= v;
                        }
                    }
                    return score;
                };
                
                // é€’å½’Negamaxï¼ˆå¸¦Î±-Î²å‰ªæï¼‰
                const negamax = (depth, Î±, Î², color) => {
                    if (depth === 0) return color * evaluate();
                    
                    const moves = [];
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const piece = this.board[r][c];
                            if (!piece || piece.type !== (color === 1 ? 'ai' : 'player')) continue;
                            
                            for (const m of this.getValidMoves(r, c)) {
                                moves.push({from:{r,c}, to:m});
                            }
                        }
                    }
                    
                    // å¼ºåˆ¶åƒå­ï¼šåªä¿ç•™åƒå­æ‹›
                    const caps = moves.filter(m => m.to.capture);
                    const pool = caps.length ? caps : moves;
                    
                    if (!pool.length) return color * evaluate();
                    
                    let value = NEG_INF;
                    for (const mv of pool) {
                        // å¿«é€Ÿ"è½å­-å›æ»š"
                        const backup = this.quickMove(mv);
                        value = Math.max(value, -negamax(depth - 1, -Î², -Î±, -color));
                        this.quickUndo(backup);
                        
                        Î± = Math.max(Î±, value);
                        if (Î± >= Î²) break; // Î²å‰ªæ
                    }
                    
                    return value;
                };
                
                // æ ¹èŠ‚ç‚¹ï¼šæ‰¾å‡ºæœ€ä½³æ‹›
                const rootMoves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (!piece || piece.type !== 'ai') continue;
                        
                        for (const m of this.getValidMoves(r, c)) {
                            rootMoves.push({from:{r,c}, to:m});
                        }
                    }
                }
                
                const caps = rootMoves.filter(m => m.to.capture);
                const pool = caps.length ? caps : rootMoves;
                
                if (!pool.length) return null;
                
                let best = NEG_INF, bestMove = pool[0];
                for (const mv of pool) {
                    const backup = this.quickMove(mv);
                    const v = -negamax(MAX_DEPTH - 1, NEG_INF, POS_INF, -1);
                    this.quickUndo(backup);
                    
                    if (v > best) {
                        best = v;
                        bestMove = mv;
                    }
                }
                
                // æ ¼å¼å¯¹é½
                return { from: {row:bestMove.from.r, col:bestMove.from.c}, to: bestMove.to };
            }

            // è¾…åŠ©å‡½æ•°ï¼šå¿«é€Ÿç§»åŠ¨
            quickMove(mv) {
                const {from, to} = mv;
                const backup = { board: this.board.map(row => row.slice()), captured: null };
                
                const piece = this.board[from.r][from.c];
                this.board[to.row][to.col] = piece;
                this.board[from.r][from.c] = null;
                
                if (to.capture) {
                    backup.captured = this.board[to.capturedRow][to.capturedCol];
                    this.board[to.capturedRow][to.capturedCol] = null;
                }
                
                // æ³¨æ„ï¼šè¿™é‡Œä¸å¤„ç†å‡çº§ï¼Œå› ä¸ºæ˜¯åœ¨makeMoveä¸­å¤„ç†çš„
                return backup;
            }

            // è¾…åŠ©å‡½æ•°ï¼šå¿«é€Ÿæ’¤é”€
            quickUndo(backup) {
                this.board = backup.board;
            }

            checkGameOver() {
                const playerPieces = this.countPieces('player');
                const aiPieces = this.countPieces('ai');
                
                if (playerPieces === 0) {
                    this.endGame('ai');
                    return true;
                }
                
                if (aiPieces === 0) {
                    this.endGame('player');
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¯ç§»åŠ¨çš„æ£‹å­
                const currentPlayerMoves = this.currentPlayer === 'player' ? 
                    this.getAllValidMoves('player') : this.getAllValidMoves('ai');
                
                if (currentPlayerMoves.length === 0) {
                    this.endGame(this.currentPlayer === 'player' ? 'ai' : 'player');
                    return true;
                }
                
                return false;
            }

            getAllValidMoves(playerType) {
                const moves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === playerType) {
                            moves.push(...this.getValidMoves(row, col));
                        }
                    }
                }
                
                return moves;
            }

            countPieces(playerType) {
                let count = 0;
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && piece.type === playerType) {
                            count++;
                        }
                    }
                }
                
                return count;
            }

            endGame(winner) {
                this.gameOver = true;
                
                if (winner === 'player') {
                    this.stats.wins++;
                    this.updateStatus('ğŸ‰æ­å–œä½ èµ¢äº†ï¼');
                } else if (winner === 'ai') {
                    this.stats.losses++;
                    this.updateStatus('ğŸ¤–å‡‰å®‰èµ¢äº†ï¼Œå†æ¥å†å‰ï¼');
                } else {
                    this.stats.draws++;
                    this.updateStatus('ğŸ¤å¹³å±€ï¼');
                }
                
                this.saveStats();
                this.updateStats();
                localStorage.removeItem('checkersGameState');
            }

            updateStatus(message) {
                const statusElement = document.getElementById('status');
                if (message) {
                    statusElement.textContent = message;
                } else if (this.currentPlayer === 'player') {
                    statusElement.textContent = 'ä½ çš„å›åˆ- è“è‰²æ£‹å­';
                } else {
                    statusElement.textContent = 'å‡‰å®‰çš„å›åˆ- æ©™è‰²æ£‹å­';
                }
            }

            updateStats() {
                document.getElementById('wins').textContent = this.stats.wins;
                document.getElementById('losses').textContent = this.stats.losses;
                document.getElementById('draws').textContent = this.stats.draws;
            }

            saveStats() {
                localStorage.setItem('checkersStats', JSON.stringify(this.stats));
            }

            loadStats() {
                const saved = localStorage.getItem('checkersStats');
                return saved ? JSON.parse(saved) : { wins: 0, losses: 0, draws: 0 };
            }

            saveGameState() {
                if (!this.gameOver) {
                    const gameState = {
                        board: this.board,
                        currentPlayer: this.currentPlayer,
                        gameOver: this.gameOver
                    };
                    localStorage.setItem('checkersGameState', JSON.stringify(gameState));
                }
            }

            loadGameState() {
                const saved = localStorage.getItem('checkersGameState');
                if (saved) {
                    try {
                        const gameState = JSON.parse(saved);
                        this.board = gameState.board;
                        this.currentPlayer = gameState.currentPlayer;
                        this.gameOver = gameState.gameOver;
                        this.renderBoard();
                        this.updateStatus();
                        
                        if (this.currentPlayer === 'ai' && !this.gameOver) {
                            setTimeout(() => this.aiMove(), 1000);
                        }
                    } catch (e) {
                        console.error('Failed to load game state:', e);
                    }
                }
            }

            reset() {
                this.board = [];
                this.currentPlayer = 'player';
                this.selectedPiece = null;
                this.validMoves = [];
                this.mustCapture = false;
                this.captureChain = false;
                this.gameOver = false;
                this.initBoard();
                this.renderBoard();
                this.updateStatus();
                localStorage.removeItem('checkersGameState');
            }
        }

        let game;

        function newGame() {
            if (game) {
                game.reset();
            } else {
                game = new CheckersGame();
            }
        }

        function resetStats() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰ç»Ÿè®¡æ•°æ®å—ï¼Ÿ')) {
                localStorage.removeItem('checkersStats');
                if (game) {
                    game.stats = { wins: 0, losses: 0, draws: 0 };
                    game.updateStats();
                }
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        window.addEventListener('DOMContentLoaded', () => {
            game = new CheckersGame();
        });

        // é˜²æ­¢é¡µé¢åˆ·æ–°æ—¶ä¸¢å¤±æ¸¸æˆçŠ¶æ€
        window.addEventListener('beforeunload', () => {
            if (game && !game.gameOver) {
                game.saveGameState();
            }
        });
    </script>
</body>
</html>
