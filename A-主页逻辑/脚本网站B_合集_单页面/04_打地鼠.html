<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å†œåœº3D æ‰“åœ°é¼ </title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(to bottom, #ff6b35 0%, #f7931e 50%, #ff8c00 100%);
            touch-action: none;
        }
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(139, 69, 19, 0.95);
            color: #fff8dc;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border-bottom: 4px solid #daa520;
        }
        .game-title {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            margin-bottom: 5px;
            color: #ffd700;
        }
        .score-coins-container {
            display: flex;
            gap: 20px;
        }
        .ui-item {
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            background: rgba(218, 165, 32, 0.3);
            padding: 5px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 2px solid rgba(255, 140, 0, 0.5);
            color: #fff8dc;
        }
        #hammer {
            position: absolute;
            width: 80px;
            height: 80px;
            pointer-events: none;
            z-index: 50;
            display: none;
            transform: translate(-50%, -50%);
            filter: drop-shadow(3px 3px 6px rgba(0,0,0,0.7));
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff8dc;
            background: rgba(139, 69, 19, 0.95);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border: 2px solid rgba(255, 140, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameUI">
        <div class="game-title">ğŸ‚ç§‹å­£å†œåœº</div>
        <div class="score-coins-container">
            <div class="ui-item">åˆ†æ•°: <span id="score">0</span></div>
            <div class="ui-item">é‡‘å¸: <span id="coins">0</span> ğŸ</div>
            <div class="ui-item"> æœ€é«˜åˆ†: <span id="highScore">0</span>ğŸ†</div>
        </div>
        <button id="resetButton" style="margin-top: 10px; padding: 5px 15px; background: rgba(218, 165, 32, 0.3); border: 2px solid rgba(255, 140, 0, 0.5); border-radius: 15px; color: #fff8dc; cursor: pointer;">é‡ç½®æˆç»©</button>
    </div>
    <div id="hammer">ğŸ</div>
    <div id="instructions">
        ç§»åŠ¨ç§‹å¶é”¤ç ¸åœ°é¼ ï¼<br>
        æŒ‰ä½å¹¶æ‹–åŠ¨å¯æ—‹è½¬è§†è§’
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // æ¸¸æˆå˜é‡
        let score = 0;
        let coins = 0;
        let highScore = 0;
        let moleGrid = 4;
        let moles = [];
        let holes = [];
        let isRotating = false;
        let lastMouseX = 0;
        let cameraRotation = 0;
        let cameraDistance = 20;
        let hammer3D = new THREE.Vector3();
        
        // æœ¬åœ°å­˜å‚¨ç®¡ç†
        const STORAGE_KEYS = {
            SCORE: 'autumnFarm_score',
            COINS: 'autumnFarm_coins',
            HIGH_SCORE: 'autumnFarm_highScore'
        };
        
        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ¸¸æˆæ•°æ® - ç«‹å³æ‰§è¡Œï¼
        function loadGameData() {
            const savedScore = localStorage.getItem(STORAGE_KEYS.SCORE);
            const savedCoins = localStorage.getItem(STORAGE_KEYS.COINS);
            const savedHighScore = localStorage.getItem(STORAGE_KEYS.HIGH_SCORE);
            
            score = savedScore ? parseInt(savedScore) : 0;
            coins = savedCoins ? parseInt(savedCoins) : 0;
            highScore = savedHighScore ? parseInt(savedHighScore) : 0;
            
            // æ›´æ–°UIæ˜¾ç¤º
            document.getElementById('score').textContent = score;
            document.getElementById('coins').textContent = coins;
            document.getElementById('highScore').textContent = highScore;
            
            console.log('ğŸ“¥ æ•°æ®å·²åŠ è½½:', { score, coins, highScore });
            console.table({ score, coins, highScore });
        }
        
        // ç«‹å³åŠ è½½å­˜å‚¨çš„æ•°æ® - åœ¨æ‰€æœ‰å…¶ä»–æ“ä½œä¹‹å‰ï¼
        loadGameData();
        
        // ä¿å­˜æ¸¸æˆæ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
        function saveGameData() {
            localStorage.setItem(STORAGE_KEYS.SCORE, score.toString());
            localStorage.setItem(STORAGE_KEYS.COINS, coins.toString());
            localStorage.setItem(STORAGE_KEYS.HIGH_SCORE, highScore.toString());
            console.log('ğŸ’¾ æ•°æ®å·²ä¿å­˜:', { score, coins, highScore });
        }
        
        // é‡ç½®æ¸¸æˆæ•°æ®
        function resetGameData() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æˆç»©å—ï¼Ÿ\nè¿™å°†æ¸…é™¤æ‚¨çš„åˆ†æ•°å’Œé‡‘å¸ï¼')) {
                score = 0;
                coins = 0;
                highScore = 0;
                saveGameData();
                
                // æ›´æ–°UIæ˜¾ç¤º
                document.getElementById('score').textContent = score;
                document.getElementById('coins').textContent = coins;
                document.getElementById('highScore').textContent = highScore;
                
                alert('æˆç»©å·²é‡ç½®ï¼');
            }
        }
        
        // æ›´æ–°æœ€é«˜åˆ†
        function updateHighScore() {
            if (score > highScore) {
                highScore = score;
                document.getElementById('highScore').textContent = highScore;
                saveGameData();
                
                // æ˜¾ç¤ºæ–°è®°å½•æç¤º
                const title = document.querySelector('.game-title');
                title.textContent = 'ğŸ‚ç§‹å­£å†œåœº - æ–°çºªå½•ï¼ğŸ†';
                title.style.color = '#ff6347';
                setTimeout(() => {
                    title.textContent = 'ğŸ‚ç§‹å­£å†œåœº';
                    title.style.color = '#ffd700';
                }, 3000);
            }
        }
        
        // Three.js åœºæ™¯è®¾ç½®
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xff8c00, 15, 100);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, cameraDistance);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0xff8c00);
        document.body.appendChild(renderer.domElement);
        
        // å…‰ç…§
        const ambientLight = new THREE.AmbientLight(0xffa500, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffd700, 0.8);
        directionalLight.position.set(15, 25, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);
        
        // åœ°é¢
        const platformGeometry = new THREE.BoxGeometry(20, 1, 20);
        const platformMaterial = new THREE.MeshLambertMaterial({
            color: 0xd2691e,
            roughness: 0.8
        });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.y = -0.5;
        platform.receiveShadow = true;
        scene.add(platform);
        
        // è‰åœ°
        const grassGeometry = new THREE.PlaneGeometry(30, 30);
        const grassMaterial = new THREE.MeshLambertMaterial({ color: 0xdaa520 });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -1;
        grass.receiveShadow = true;
        scene.add(grass);
        
        // åˆ›å»ºå±±å³°
        function createMountains() {
            for (let i = 0; i < 5; i++) {
                const mountainGeometry = new THREE.ConeGeometry(8 + Math.random() * 4, 15 + Math.random() * 10, 6);
                const mountainMaterial = new THREE.MeshLambertMaterial({ color: 0xb22222 });
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                const angle = (i / 5) * Math.PI * 2;
                const distance = 40 + Math.random() * 20;
                mountain.position.set(
                    Math.sin(angle) * distance,
                    -5,
                    Math.cos(angle) * distance
                );
                scene.add(mountain);
            }
        }
        createMountains();
        
        // åˆ›å»ºå†œåœºè£…é¥°
        function createFarmDecorations() {
            // åˆ›å»ºæ ‘æœ¨
            function createTree(x, z) {
                const treeGroup = new THREE.Group();
                // æ ‘å¹²
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 4);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                // æ ‘å† 
                const crownGeometry = new THREE.SphereGeometry(2.5, 8, 6);
                const crownMaterial = new THREE.MeshLambertMaterial({ color: 0xff6347 });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = 5;
                crown.castShadow = true;
                crown.receiveShadow = true;
                treeGroup.add(crown);
                treeGroup.position.set(x, 0, z);
                return treeGroup;
            }
            
            // æ·»åŠ æ ‘æœ¨
            const treePositions = [
                [-25, -25], [-20, -30], [-30, -20],
                [25, -25], [20, -30], [30, -20],
                [-25, 25], [-20, 30], [-30, 20],
                [25, 25], [20, 30], [30, 20]
            ];
            treePositions.forEach(pos => {
                scene.add(createTree(pos[0], pos[1]));
            });
            
            // åˆ›å»ºå¹²è‰å †
            function createHaystack(x, z) {
                const hayGeometry = new THREE.CylinderGeometry(1.5, 2, 2);
                const hayMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                const hay = new THREE.Mesh(hayGeometry, hayMaterial);
                hay.position.set(x, 1, z);
                hay.castShadow = true;
                hay.receiveShadow = true;
                return hay;
            }
            
            // æ·»åŠ å¹²è‰å †
            scene.add(createHaystack(-12, -12));
            scene.add(createHaystack(12, 12));
            scene.add(createHaystack(-12, 12));
            scene.add(createHaystack(12, -12));
        }
        createFarmDecorations();
        
        // åˆ›å»ºåœ°é¼ æ´
        function createHoles() {
            const spacing = 4;
            const start = -(moleGrid - 1) * spacing / 2;
            for (let i = 0; i < moleGrid; i++) {
                for (let j = 0; j < moleGrid; j++) {
                    // æ´çš„å¤–éƒ¨
                    const holeOuterGeometry = new THREE.CylinderGeometry(1.2, 1.4, 0.3);
                    const holeOuterMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                    const holeOuter = new THREE.Mesh(holeOuterGeometry, holeOuterMaterial);
                    holeOuter.position.set(start + i * spacing, 0.15, start + j * spacing);
                    holeOuter.receiveShadow = true;
                    scene.add(holeOuter);
                    
                    // æ´çš„å†…éƒ¨
                    const holeInnerGeometry = new THREE.CylinderGeometry(1, 1, 0.2);
                    const holeInnerMaterial = new THREE.MeshLambertMaterial({ color: 0x2f1b14 });
                    const holeInner = new THREE.Mesh(holeInnerGeometry, holeInnerMaterial);
                    holeInner.position.set(start + i * spacing, 0.05, start + j * spacing);
                    holeInner.receiveShadow = true;
                    scene.add(holeInner);
                    
                    holes.push({
                        x: start + i * spacing,
                        z: start + j * spacing,
                        occupied: false
                    });
                }
            }
        }
        createHoles();
        
        // åˆ›å»ºåœ°é¼ 
        function createMole() {
            const moleGroup = new THREE.Group();
            // èº«ä½“
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 12);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            moleGroup.add(body);
            
            // å¤´éƒ¨
            const headGeometry = new THREE.SphereGeometry(0.8, 16, 12);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xa0522d });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.2;
            head.castShadow = true;
            head.receiveShadow = true;
            moleGroup.add(head);
            
            // é¼»å­
            const noseGeometry = new THREE.SphereGeometry(0.2, 8, 6);
            const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xff4500 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 1.2, 0.6);
            nose.castShadow = true;
            moleGroup.add(nose);
            
            // çœ¼ç›
            const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 6);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 1.4, 0.5);
            moleGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 1.4, 0.5);
            moleGroup.add(rightEye);
            
            // è€³æœµ
            const earGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const earMaterial = new THREE.MeshLambertMaterial({ color: 0xa0522d });
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.5, 1.8, 0);
            leftEar.castShadow = true;
            moleGroup.add(leftEar);
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.5, 1.8, 0);
            rightEar.castShadow = true;
            moleGroup.add(rightEar);
            
            return moleGroup;
        }
        
        // åˆ›å»ºé‡‘å¸
        function createCoin() {
            const coinGroup = new THREE.Group();
            // é‡‘å¸ä¸»ä½“
            const coinGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
            const coinMaterial = new THREE.MeshLambertMaterial({
                color: 0xff6347,
                shininess: 100
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.castShadow = true;
            coin.receiveShadow = true;
            coinGroup.add(coin);
            
            // é‡‘å¸ä¸Šçš„æ˜Ÿæ˜Ÿè£…é¥°
            const starGeometry = new THREE.ConeGeometry(0.2, 0.05, 5);
            const starMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.y = 0.1;
            star.rotation.x = Math.PI / 2;
            coinGroup.add(star);
            
            return coinGroup;
        }
        
        // åœ°é¼ ç±»
        class Mole {
            constructor(hole) {
                this.hole = hole;
                this.mesh = createMole();
                this.mesh.position.set(hole.x, -2, hole.z);
                this.isUp = false;
                this.isHit = false;
                this.upDuration = 2000 + Math.random() * 2000;
                this.upStartTime = 0;
                this.speed = 0.08 + Math.random() * 0.04;
                this.hitbox = new THREE.Box3();
                scene.add(this.mesh);
            }
            
            show() {
                if (!this.isUp && !this.isHit) {
                    this.isUp = true;
                    this.upStartTime = Date.now();
                }
            }
            
            hide() {
                if (this.isUp && !this.isHit) {
                    this.isUp = false;
                }
            }
            
            checkHammerCollision(hammerPosition) {
                if (this.isUp && !this.isHit) {
                    this.hitbox.setFromObject(this.mesh);
                    const distance = hammerPosition.distanceTo(this.mesh.position);
                    if (distance < 2.5) {
                        this.hit();
                        return true;
                    }
                }
                return false;
            }
            
            hit() {
                if (this.isUp && !this.isHit) {
                    this.isHit = true;
                    score += 50;
                    document.getElementById('score').textContent = score;
                    
                    // æ›´æ–°æœ€é«˜åˆ†å¹¶ä¿å­˜
                    updateHighScore();
                    saveGameData();
                    
                    this.createHitEffect();
                    
                    if (Math.random() < 0.3) {
                        this.dropCoin();
                    }
                    
                    let spinCount = 0;
                    const spinAnimation = () => {
                        if (spinCount < 30) {
                            this.mesh.rotation.y += 0.3;
                            this.mesh.position.y -= 0.15;
                            this.mesh.scale.multiplyScalar(0.95);
                            spinCount++;
                            requestAnimationFrame(spinAnimation);
                        } else {
                            this.destroy();
                        }
                    };
                    spinAnimation();
                }
            }
            
            createHitEffect() {
                const particleCount = 10;
                for (let i = 0; i < particleCount; i++) {
                    const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff6347 : 0xffd700
                    });
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.copy(this.mesh.position);
                    particle.position.y += 1;
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.4 + 0.1,
                        (Math.random() - 0.5) * 0.3
                    );
                    scene.add(particle);
                    let life = 30;
                    const animateParticle = () => {
                        if (life > 0) {
                            particle.position.add(velocity);
                            velocity.y -= 0.015;
                            particle.material.opacity = life / 30;
                            particle.material.transparent = true;
                            life--;
                            requestAnimationFrame(animateParticle);
                        } else {
                            scene.remove(particle);
                        }
                    };
                    animateParticle();
                }
            }
            
            dropCoin() {
                const coin = createCoin();
                coin.position.set(this.hole.x, this.mesh.position.y + 2, this.hole.z);
                scene.add(coin);
                const velocity = { y: 0.15, rotation: 0.2 };
                const coinAnimation = () => {
                    if (coin.position.y > 0.2) {
                        coin.position.y += velocity.y;
                        velocity.y -= 0.008;
                        coin.rotation.y += velocity.rotation;
                        requestAnimationFrame(coinAnimation);
                    } else {
                        setTimeout(() => {
                            let moveCount = 0;
                            const collectAnimation = () => {
                                if (moveCount < 20) {
                                    coin.position.y += 0.1;
                                    coin.position.x += (0 - coin.position.x) * 0.1;
                                    coin.position.z += (15 - coin.position.z) * 0.1;
                                    coin.scale.multiplyScalar(0.9);
                                    moveCount++;
                                    requestAnimationFrame(collectAnimation);
                                } else {
                                    coins += 5;
                                    document.getElementById('coins').textContent = coins;
                                    // ä¿å­˜æ¸¸æˆæ•°æ®
                                    saveGameData();
                                    scene.remove(coin);
                                }
                            };
                            collectAnimation();
                        }, 500);
                    }
                };
                coinAnimation();
            }
            
            update() {
                if (this.isHit) return;
                
                if (this.isUp) {
                    if (this.mesh.position.y < 1.5) {
                        this.mesh.position.y += this.speed;
                    } else if (Date.now() - this.upStartTime > this.upDuration) {
                        this.hide();
                    }
                } else {
                    if (this.mesh.position.y > -2) {
                        this.mesh.position.y -= this.speed;
                    }
                }
            }
            
            destroy() {
                scene.remove(this.mesh);
                this.hole.occupied = false;
                const index = moles.indexOf(this);
                if (index > -1) {
                    moles.splice(index, 1);
                }
            }
        }
        
        // éšæœºç”Ÿæˆåœ°é¼ 
        function spawnMole() {
            const availableHoles = holes.filter(hole => !hole.occupied);
            if (availableHoles.length > 0) {
                const randomHole = availableHoles[Math.floor(Math.random() * availableHoles.length)];
                randomHole.occupied = true;
                const mole = new Mole(randomHole);
                moles.push(mole);
                setTimeout(() => {
                    mole.show();
                }, Math.random() * 2000);
            }
        }
        
        // å®šæœŸç”Ÿæˆåœ°é¼ 
        let spawnInterval = setInterval(spawnMole, 1500);
        
        // Raycaster ç”¨äºæ£€æµ‹é”¤å­ä½ç½®
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // æ›´æ–°æ‘„åƒæœºä½ç½®
        function updateCameraPosition() {
            camera.position.x = Math.sin(cameraRotation) * cameraDistance;
            camera.position.z = Math.cos(cameraRotation) * cameraDistance;
            camera.lookAt(0, 0, 0);
        }
        
        // é¼ æ ‡/è§¦æ‘¸äº‹ä»¶
        function onMouseMove(event) {
            const x = event.clientX || (event.touches && event.touches[0].clientX);
            const y = event.clientY || (event.touches && event.touches[0].clientY);
            
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            
            // æ›´æ–°é”¤å­ä½ç½®
            const hammer = document.getElementById('hammer');
            hammer.style.left = x + 'px';
            hammer.style.top = y + 'px';
            hammer.style.display = 'block';
            
            // æ›´æ–°3Dé”¤å­çš„ä½ç½®
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(platform);
            if (intersects.length > 0) {
                hammer3D.copy(intersects[0].point);
                hammer3D.y += 1;
                
                // æ£€æŸ¥é”¤å­ä¸åœ°é¼ çš„ç¢°æ’
                moles.forEach(mole => {
                    mole.checkHammerCollision(hammer3D);
                });
            }
            
            // å¦‚æœæ­£åœ¨æ—‹è½¬ç›¸æœº
            if (isRotating) {
                const deltaX = x - lastMouseX;
                cameraRotation += deltaX * 0.01;
                updateCameraPosition();
                lastMouseX = x;
            }
        }
        
        function onMouseDown(event) {
            const x = event.clientX || (event.touches && event.touches[0].clientX);
            const y = event.clientY || (event.touches && event.touches[0].clientY);
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨å¹³å°åŒºåŸŸå¤–
            if (y < 100 || y > window.innerHeight - 100) {
                isRotating = true;
                lastMouseX = x;
                document.getElementById('hammer').style.display = 'none';
            }
        }
        
        function onMouseUp() {
            isRotating = false;
            document.getElementById('hammer').style.display = 'block';
        }
        
        // äº‹ä»¶ç›‘å¬
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('touchmove', onMouseMove);
        document.addEventListener('touchstart', onMouseDown);
        document.addEventListener('touchend', onMouseUp);
        
        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // é‡ç½®æŒ‰é’®äº‹ä»¶ç›‘å¬
        document.getElementById('resetButton').addEventListener('click', resetGameData);
        
        // æ¸¸æˆå¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°åœ°é¼ 
            moles.forEach(mole => mole.update());
            
            // å®šæœŸæ¸…ç†è¿‡æœŸçš„åœ°é¼ 
            if (moles.length > 8) {
                const oldMole = moles.find(m => !m.isUp && !m.isHit && m.mesh.position.y <= -1.5);
                if (oldMole) {
                    oldMole.destroy();
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // å¼€å§‹æ¸¸æˆ
        // âŒ åˆ é™¤äº†åˆå§‹åŒ–æ—¶ä¿å­˜é»˜è®¤å€¼çš„ä»£ç ï¼Œé˜²æ­¢è¦†ç›–å­˜å‚¨æ•°æ®
        // saveGameData(); 
        animate();
        
        // åˆå§‹ç”Ÿæˆå‡ ä¸ªåœ°é¼ 
        setTimeout(() => {
            for (let i = 0; i < 3; i++) {
                setTimeout(spawnMole, i * 800);
            }
        }, 1000);
    </script>
</body>
</html>
