<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>霓虹深渊- Neon Abyss</title>
    <style>
        /* --- 基础样式 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* 禁止浏览器默认的触摸行为 */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* --- UI 层 --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* --- 游戏内 HUD --- */
        .hud-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hud-box {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }

        .hud-label {
            color: #888;
            font-size: 12px;
            display: block;
            margin-bottom: 2px;
        }

        .hud-value {
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            font-size: 24px;
            font-weight: bold;
            font-variant-numeric: tabular-nums; /* 等宽数字，防止跳动 */
        }

        #speed-value.danger {
            color: #f00;
            text-shadow: 0 0 10px #f00;
        }

        /* --- 全屏弹窗 (开始/结束) --- */
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            background: rgba(10, 0, 26, 0.85); /* 深紫色半透明背景 */
            backdrop-filter: blur(10px);
            z-index: 20;
            transition: opacity 0.5s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        /* --- 启动页优化 --- */
        .title-container {
            text-align: center;
            margin-bottom: 40px;
            animation: float 3s ease-in-out infinite;
        }

        h1 {
            color: #f0f;
            font-size: 56px;
            margin: 0;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 
                0 0 10px #f0f,
                0 0 20px #f0f,
                0 0 40px #a0f;
            font-style: italic;
            position: relative;
        }

        h1::after {
            content: 'NEON ABYSS';
            display: block;
            font-size: 14px;
            color: #fff;
            letter-spacing: 8px;
            margin-top: 5px;
            text-shadow: none;
            opacity: 0.8;
            font-style: normal;
        }

        .high-score-badge {
            margin-top: 20px;
            display: inline-block;
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid #f0f;
            padding: 5px 15px;
            border-radius: 20px;
            color: #f0f;
            font-size: 16px;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
        }

        .instructions {
            color: #ccc;
            margin-bottom: 40px;
            font-size: 16px;
            line-height: 1.6;
            text-align: center;
            max-width: 80%;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
        }

        .instructions span {
            color: #0ff;
            font-weight: bold;
        }

        /* --- 按钮样式 --- */
        .neon-btn {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 18px 60px;
            font-size: 26px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
            font-family: inherit;
        }

        .neon-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.4), transparent);
            transition: 0.5s;
        }

        .neon-btn:hover::before {
            left: 100%;
        }

        .neon-btn:active {
            transform: scale(0.95);
        }

        .neon-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px #0f0;
        }

        /* --- 游戏结束界面 --- */
        #game-over-screen {
            background: rgba(50, 0, 0, 0.9);
        }

        .result-box {
            margin-bottom: 30px;
            text-align: center;
        }

        .result-label {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .result-score {
            font-size: 48px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            margin: 5px 0;
        }

        .new-record {
            color: #ff0;
            font-size: 20px;
            animation: pulse 1s infinite;
            display: none; /* JS控制显示 */
            margin-top: 5px;
        }

        #restart-btn {
            border-color: #f00;
            color: #f00;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
        }

        #restart-btn:hover {
            background: #f00;
            color: #fff;
            box-shadow: 0 0 30px #f00;
        }

        /* --- 动画 --- */
        @keyframes pulse {
            0% { opacity: 0.5; text-shadow: 0 0 5px #ff0; }
            50% { opacity: 1; text-shadow: 0 0 20px #ff0; }
            100% { opacity: 0.5; text-shadow: 0 0 5px #ff0; }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

    </style>
</head>
<body>

    <!-- 游戏画布容器 -->
    <div id="canvas-container"></div>

    <!-- 游戏内HUD界面 -->
    <div id="ui-layer">
        <div class="hud-container">
            <div class="hud-box">
                <span class="hud-label">SCORE</span>
                <span id="score-display" class="hud-value">0</span>
            </div>
            <div class="hud-box">
                <span class="hud-label">SPEED</span>
                <span id="speed-value" class="hud-value">100%</span>
            </div>
        </div>
    </div>

    <!-- 启动界面 -->
    <div id="start-screen" class="screen-overlay">
        <div class="title-container">
            <h1>霓虹深渊</h1>
            <div class="high-score-badge">BEST: <span id="start-high-score">0</span></div>
        </div>
        
        <div class="instructions">
            <p>左右拖动控制飞船</p>
            <p>躲避 <span style="color:#f0f">紫色晶体</span></p>
            <p>存活越久，分数越高</p>
        </div>

        <button id="start-btn" class="neon-btn">启动引擎</button>
    </div>

    <!-- 游戏结束界面 -->
    <div id="game-over-screen" class="screen-overlay hidden">
        <h1 style="color: #f00; text-shadow: 0 0 20px #f00; font-size: 42px; margin-bottom: 20px;">信号丢失</h1>
        
        <div class="result-box">
            <div class="result-label">本次得分</div>
            <div id="final-score" class="result-score">0</div>
            <div id="new-record-tag" class="new-record">★ 新纪录! ★</div>
        </div>

        <div class="result-box">
            <div class="result-label">历史最高</div>
            <div id="game-over-high-score" class="result-score" style="color: #f0f;">0</div>
        </div>

        <button id="restart-btn" class="neon-btn">重新连接</button>
    </div>

    <!-- 引入Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 游戏配置 ---
        const CONFIG = {
            baseSpeed: 0.8,
            speedIncrement: 0.0005,
            maxSpeed: 3.0,
            laneWidth: 16, // 略微加宽适应手机横屏比例，但主要限制Y轴
            spawnRate: 40,
            colors: {
                player: 0x00ffff,
                obstacle: 0xff00ff,
                fog: 0x0a001a,
                star: 0xffffff
            }
        };

        // --- 全局变量 ---
        let scene, camera, renderer;
        let player;
        let obstacles = [];
        let particles = [];
        let stars;
        let gameActive = false;
        let score = 0;
        let speed = CONFIG.baseSpeed;
        let frameCount = 0;
        
        // 输入控制
        let targetX = 0;
        let targetY = 0;
        let currentInputX = 0; // 用于平滑输入

        // 本地存储Key
        const STORAGE_KEY = 'neon_abyss_highscore_v1';
        let highScore = parseInt(localStorage.getItem(STORAGE_KEY)) || 0;

        // DOM 元素
        const scoreEl = document.getElementById('score-display');
        const speedEl = document.getElementById('speed-value');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const startHighScoreEl = document.getElementById('start-high-score');
        const gameOverHighScoreEl = document.getElementById('game-over-high-score');
        const newRecordTag = document.getElementById('new-record-tag');
        
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');

        // 初始化显示最高分
        startHighScoreEl.innerText = highScore;

        // --- 初始化 ---
        function init() {
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.035);
            scene.background = new THREE.Color(CONFIG.colors.fog);

            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;
            camera.position.y = 0.5; // 相机稍微抬高一点，更有纵深感

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 优化性能
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 灯光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(0, 10, 5);
            scene.add(dirLight);

            // 玩家飞船 (更锐利的四面体)
            const playerGeometry = new THREE.ConeGeometry(0.5, 2, 4);
            playerGeometry.rotateX(Math.PI / 2);
            playerGeometry.rotateY(Math.PI / 4);
            
            const playerMaterial = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.player,
                emissive: CONFIG.colors.player,
                emissiveIntensity: 0.8,
                roughness: 0.1,
                metalness: 0.8
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            scene.add(player);

            // 飞船引擎光
            const playerLight = new THREE.PointLight(CONFIG.colors.player, 3, 15);
            playerLight.position.set(0, 0, 1);
            player.add(playerLight);

            // 背景星空
            createStarfield();

            // 事件监听
            window.addEventListener('resize', onWindowResize, false);
            
            // 触摸事件 (手机端)
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, { passive: false });

            // 鼠标事件 (PC调试用，保留)
            document.addEventListener('mousemove', onMouseMove);

            startBtn.addEventListener('click', startGame);
            restartBtn.addEventListener('click', startGame);

            // 开始渲染循环
            animate();
        }

        function createStarfield() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 1500;
            const posArray = new Float32Array(starCount * 3);

            for(let i = 0; i < starCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            const starMat = new THREE.PointsMaterial({
                color: CONFIG.colors.star,
                size: 0.15,
                transparent: true,
                opacity: 0.8
            });
            stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);
        }

        // --- 游戏逻辑 ---

        function startGame() {
            gameActive = true;
            score = 0;
            speed = CONFIG.baseSpeed;
            frameCount = 0;

            // 清理障碍物
            obstacles.forEach(ob => scene.remove(ob.mesh));
            obstacles = [];

            // 重置玩家
            player.position.set(0, 0, 0);
            targetX = 0;
            targetY = 0;
            currentInputX = 0; // 重置输入平滑值

            // UI 更新
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            updateHUD();
        }

        function gameOver() {
            gameActive = false;
            createExplosion(player.position, 40, CONFIG.colors.player);
            
            const currentScore = Math.floor(score);
            let isNewRecord = false;

            // 检查最高分
            if (currentScore > highScore) {
                highScore = currentScore;
                localStorage.setItem(STORAGE_KEY, highScore);
                isNewRecord = true;
            }

            // 更新UI
            finalScoreEl.innerText = `SCORE: ${currentScore}`;
            gameOverHighScoreEl.innerText = `BEST: ${highScore}`;
            startHighScoreEl.innerText = highScore; // 更新主页显示
            
            if (isNewRecord) {
                newRecordTag.style.display = 'block';
            } else {
                newRecordTag.style.display = 'none';
            }

            // 延迟一点显示结束画面，让玩家看到爆炸
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 500);
        }

        function spawnObstacle() {
            let geometry;
            const type = Math.random();
            if (type > 0.5) {
                geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            } else {
                geometry = new THREE.OctahedronGeometry(0.8);
            }

            const material = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.obstacle,
                emissive: 0xaa00aa,
                emissiveIntensity: 0.6,
                wireframe: Math.random() > 0.85
            });

            const mesh = new THREE.Mesh(geometry, material);

            // 生成位置：主要在X轴分布，Y轴略微偏移
            const x = (Math.random() - 0.5) * CONFIG.laneWidth;
            const y = (Math.random() - 0.5) * (CONFIG.laneWidth / 3);
            const z = -60;

            mesh.position.set(x, y, z);
            
            mesh.userData = {
                rotSpeedX: (Math.random() - 0.5) * 0.15,
                rotSpeedY: (Math.random() - 0.5) * 0.15
            };

            scene.add(mesh);
            obstacles.push({ mesh: mesh, box: new THREE.Box3() });
        }

        function createExplosion(position, count, color) {
            const particleGeo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < count; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push(
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8
                );
            }
            particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const particleMat = new THREE.PointsMaterial({
                color: color,
                size: 0.3,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(particleGeo, particleMat);
            particleSystem.userData = { velocities: velocities, age: 0 };
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        // --- 核心循环 ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 玩家移动
            if (gameActive) {
                // 边界限制
                targetX = Math.max(-CONFIG.laneWidth/2, Math.min(CONFIG.laneWidth/2, targetX));
                targetY = Math.max(-3, Math.min(3, targetY));

                // 平滑插值移动
                player.position.x += (targetX - player.position.x) * 0.15;
                player.position.y += (targetY - player.position.y) * 0.15;

                // 飞船倾斜
                player.rotation.z = -(player.position.x - targetX) * 0.4;
                player.rotation.x = (player.position.y - targetY) * 0.2;

                // 增加速度
                speed = Math.min(CONFIG.maxSpeed, speed + CONFIG.speedIncrement);
                score += speed;
                updateHUD();

                // 悬浮感
                player.position.z = Math.sin(Date.now() * 0.005) * 0.2;
            }

            // 2. 背景星空移动
            if (stars) {
                const positions = stars.geometry.attributes.position.array;
                const currentSpeed = gameActive ? speed * 2 : 0.3; // 待机时也有微动
                
                for(let i = 2; i < positions.length; i += 3) {
                    positions[i] += currentSpeed;
                    if (positions[i] > 10) {
                        positions[i] = -100;
                    }
                }
                stars.geometry.attributes.position.needsUpdate = true;
                // 星星稍微旋转
                stars.rotation.z += 0.0005;
            }

            // 3. 障碍物管理
            if (gameActive) {
                frameCount++;
                const currentSpawnRate = Math.max(10, Math.floor(CONFIG.spawnRate / speed));

                if (frameCount % currentSpawnRate === 0) {
                    spawnObstacle();
                }

                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const ob = obstacles[i];
                    ob.mesh.position.z += speed;
                    ob.mesh.rotation.x += ob.mesh.userData.rotSpeedX;
                    ob.mesh.rotation.y += ob.mesh.userData.rotSpeedY;

                    // 简单的距离检测 (比Box3更省性能)
                    const dist = player.position.distanceTo(ob.mesh.position);
                    
                    // 碰撞判定阈值稍微调小一点，手感更好
                    if (dist < 0.9) {
                        gameOver();
                    }

                    if (ob.mesh.position.z > 6) {
                        scene.remove(ob.mesh);
                        obstacles.splice(i, 1);
                    }
                }
            }

            // 4. 粒子效果
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.userData.age++;
                
                const positions = p.geometry.attributes.position.array;
                const vels = p.userData.velocities;

                for (let j = 0; j < positions.length; j += 3) {
                    positions[j] += vels[j];
                    positions[j+1] += vels[j+1];
                    positions[j+2] += vels[j+2];
                }
                p.geometry.attributes.position.needsUpdate = true;
                
                p.material.opacity = 1 - (p.userData.age / 60);
                
                if (p.userData.age > 60) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- 辅助函数 ---
        function updateHUD() {
            scoreEl.innerText = Math.floor(score);
            const speedPercent = Math.floor((speed / CONFIG.baseSpeed) * 100);
            speedEl.innerText = speedPercent + "%";

            // 速度颜色变化
            if (speedPercent > 200) {
                speedEl.classList.add('danger');
            } else {
                speedEl.classList.remove('danger');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 输入处理 ---
        
        // 处理触摸开始
        function onTouchStart(event) {
            if (!gameActive) return;
            event.preventDefault();
            updateTargetFromTouch(event.touches[0]);
        }

        // 处理触摸移动
        function onTouchMove(event) {
            if (!gameActive) return;
            event.preventDefault();
            updateTargetFromTouch(event.touches[0]);
        }

        // 处理触摸结束
        function onTouchEnd(event) {
            if (!gameActive) return;
            // 可选：松手后飞船回中？或者停在最后位置？
            // 暂时停在最后位置体验更好
        }

        function updateTargetFromTouch(touch) {
            // 将屏幕坐标映射到游戏世界坐标
            // NDC range: -1 to 1
            const ndcX = (touch.clientX / window.innerWidth) * 2 - 1;
            const ndcY = -(touch.clientY / window.innerHeight) * 2 + 1;

            // 映射到 laneWidth 范围
            // 宽范围大一点，窄范围小一点以适应竖屏
            targetX = ndcX * (CONFIG.laneWidth / 2);
            targetY = ndcY * 4; // Y轴移动范围限制在 -4 到 4
        }

        function onMouseMove(event) {
            if (!gameActive) return;
            const ndcX = (event.clientX / window.innerWidth) * 2 - 1;
            const ndcY = -(event.clientY / window.innerHeight) * 2 + 1;
            targetX = ndcX * (CONFIG.laneWidth / 2);
            targetY = ndcY * 4;
        }

        // 启动
        init();

    </script>
</body>
</html>
